using Microsoft.CodeAnalysis;
using OrmGenerator.Models;
using OrmGenerator.Utility;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace OrmGenerator;

[Generator]
public class MainGenerator : IIncrementalGenerator
{
	private const string _baseMarker = "OrmGenerator.OrmModelAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static ctx =>
		{
			ctx.AddSource("OrmModelAttribute.g.cs",
				"""
				/// <auto-generated/>
				
				using System;
				namespace OrmGenerator;

				[AttributeUsage(AttributeTargets.Class)]
				internal class OrmModelAttribute : Attribute
				{
					public bool GenerateToString { get; set; } = false;
				}

				internal sealed class NestableOrmModelAttribute : OrmModelAttribute;
				""");
			ctx.AddSource("IOrmModel.g.cs",
				"""
				/// <auto-generated/>
				
				using System.Data.Common;
				namespace OrmGenerator;

				/// <summary>
				/// Represents a model of type with source-generated mapping.
				/// This interface is used internally by the generator and it's not advised to use it elsewhere.
				/// </summary>
				public interface IOrmModel<TSelf> where TSelf : class
				{
					
					/// <summary>
					/// Initializes a new instance of the <see cref="TSelf"/> class.
					/// Provides a mechanism to handle nested models.
					/// This method is used internally by the generator and it's not advised to use it elsewhere.
					/// </summary>
					/// <typeparam name="TSelf">Model type returned from mapping</typeparam>
					internal static abstract TSelf GetSingleModel(DbDataReader reader);
				}
				""");

			ctx.AddSource("DbCommandExtensions.g.cs",
				"""
				/// <auto-generated/>
				
				#nullable enable

				using System.Data;
				using System.Data.Common;
				using System.Runtime.CompilerServices;
				namespace OrmGenerator;
				
				public static class DbCommandExtensions
				{
					/// <summary>
					/// Executes the query defined in the <paramref name="command"/> parameter and maps the result to a single instance of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A mapped <typeparamref name="TModel"/> instance or <c>null</c> if the query result is empty.</returns>
					public static TModel? GetSingle<TModel>(this DbCommand command) where TModel: class, IOrmModel<TModel>
					{
						using DbDataReader reader = command.ExecuteReader(CommandBehavior.SingleRow);
						return reader.Read() 
							? TModel.GetSingleModel(reader) 
							: null;
					}

					/// <summary>
					/// Asynchronously executes the query defined in the <paramref name="command"/> parameter and maps the result to a single instance of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A <see cref="Task{TModel}"/> containing a mapped <typeparamref name="TModel"/> instance or <c>null</c> if the query result is empty.</returns>
					public static async Task<TModel?> GetSingleAsync<TModel>(this DbCommand command, CancellationToken token = default) where TModel: class, IOrmModel<TModel>
					{
						using DbDataReader reader = await command.ExecuteReaderAsync(CommandBehavior.SingleRow, token);
						return await reader.ReadAsync(token) 
							? TModel.GetSingleModel(reader) 
							: null;
					}

					/// <summary>
					/// Executes the query defined in the <paramref name="command"/> parameter, maps the results and returns them as a <see cref="List{}"/> of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A <see cref="List{}" /> of mapped <typeparamref name="TModel"/>s.</returns>
					public static List<TModel> GetListOf<TModel>(this DbCommand command) where TModel: class, IOrmModel<TModel>
					{
						List<TModel> result = [];
						using DbDataReader reader = command.ExecuteReader();
				
						while(reader.Read())
							result.Add(TModel.GetSingleModel(reader));
						return result;
					}

					/// <summary>
					/// Asynchronously executes the query defined in the <paramref name="command"/> parameter, maps the results and returns them as a <see cref="Task{}"/> of <see cref="List{}"/> of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A <see cref="Task{TModel}"/> containing a <see cref="List{}" /> of mapped <typeparamref name="TModel"/>s.</returns>
					public static async Task<List<TModel>> GetListOfAsync<TModel>(this DbCommand command, CancellationToken token = default) where TModel: class, IOrmModel<TModel>
					{
						List<TModel> result = [];
						using DbDataReader reader = await command.ExecuteReaderAsync(token);
				
						while(await reader.ReadAsync(token))
							result.Add(TModel.GetSingleModel(reader));
						return result;
					}

					/// <summary>
					/// Executes the query defined in the <paramref name="command"/> parameter, maps the results and returns them as a lazily evaluated <see cref="IEnumerable{}"/> of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A lazily evaluated <see cref="IEnumerable{}"/> of mapped <typeparamref name="TModel"/>s.</returns>
					public static IEnumerable<TModel> GetEnumerableOf<TModel>(this DbCommand command) where TModel: class, IOrmModel<TModel>
					{
						using DbDataReader reader = command.ExecuteReader();
				
						while(reader.Read())
							yield return TModel.GetSingleModel(reader);
					}

					/// <summary>
					/// Asynchronously executes the query defined in the <paramref name="command"/> parameter, maps the results and returns them as a lazily evaluated <see cref="IAsyncEnumerable{}"/> of <typeparamref name="TModel"/>.
					/// </summary>
					/// <param name="command"> The command to source data from.</param>
					/// <typeparam name="TModel"> Type of the model used as a result of mapping.</typeparam>
					/// <returns>A lazily evaluated <see cref="IAsyncEnumerable{}"/> of mapped <typeparamref name="TModel"/>s.</returns>
					public static async IAsyncEnumerable<TModel> GetAsyncEnumerableOf<TModel>(this DbCommand command, [EnumeratorCancellation] CancellationToken token = default) where TModel: class, IOrmModel<TModel>
					{
						using DbDataReader reader = await command.ExecuteReaderAsync(token);
				
						while(await reader.ReadAsync(token))
							yield return TModel.GetSingleModel(reader);
					}
				}
				""");
		});

		IncrementalValuesProvider<MetadataModel> provider = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				_baseMarker,
				predicate: static (node, _) => true,
				transform: static (context, token) =>
				{
					INamedTypeSymbol @class = (INamedTypeSymbol)context.TargetSymbol;
					bool generateToString = GetToStringInfo(context);
					ImmutableArray<(string, DbDataType)> prop = @class
						.GetMembers()
						.OfType<IPropertySymbol>()
						.Where(static p => p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedOrInternal && p.SetMethod is not null)
						.Select(static p => Enum.TryParse(p.Type.Name, true, out DbDataType dataType)
								? (p.Name, dataType)
								: (p.Name, DbDataType.Unknown))
						.ToImmutableArray();
					return new MetadataModel(@class.Name, @class.ContainingNamespace.Name, prop, generateToString);
				}
			);
		context.RegisterSourceOutput(provider, static (spc, model) =>
		{
			StringBuilder builder = new();
			(string name,
			string @namespace,
			bool generateToString,
			ImmutableArray<(string Name, DbDataType Type)> properties) = model;

			builder.AppendLine(
			$$"""
			/// <auto-generated/>
			
			using System.Data.Common;
			using OrmGenerator;

			namespace {{@namespace}};
			partial class {{name}} : IOrmModel<{{name}}>
			{
				public static {{name}} GetSingleModel(DbDataReader reader, ref int index) => new()
				{
			""");

			foreach ((string, DbDataType) prop in properties)
			{
				(string Name, DbDataType Type) = prop;
				builder.AppendLine($"		{Name} = reader.Get{(Type == DbDataType.Single ? "Float" : Type.ToString())}(index++),");
			}

			builder.AppendLine($$"""
				};
				public static {{name}} GetSingleModel(DbDataReader reader)
				{
					int index = 0;
					return GetSingleModel(reader, ref index);
				}
			""");
			if (model.GenerateToString)
			{
				builder.AppendLine($$""""
						public override string ToString() =>
							$"""
					"""");
				foreach ((string Name, DbDataType) prop in properties)
					builder.AppendLine($"		{prop.Name}: {{{prop.Name}}}");
				builder.AppendLine("	\"\"\";");
			}
			builder.AppendLine("}");

			spc.AddSource($"{@namespace}.{name}.g.cs", builder.ToString());
		});

		IncrementalValuesProvider<NestableMetadataModel> nestableProvider = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				"OrmGenerator.NestableOrmModelAttribute",
				predicate: static (node, _) => true,
				transform: static (context, token) =>
				{
					INamedTypeSymbol @class = (INamedTypeSymbol)context.TargetSymbol;
					bool generateToString = GetToStringInfo(context);
					ImmutableArray<(string, DbDataType, string?)> prop = @class
						.GetMembers()
						.OfType<IPropertySymbol>()
						.Where(static p => p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedOrInternal && p.SetMethod is not null)
						.Select(static p => Enum.TryParse(p.Type.Name, true, out DbDataType type)
								? (p.Name, type, null)
								: (p.Name, DbDataType.Unknown, p.Type.Name)
						)
						.ToImmutableArray();
					return new NestableMetadataModel(@class.Name, @class.ContainingNamespace.Name, prop, generateToString);
				}
			);
		context.RegisterSourceOutput(nestableProvider, static (spc, model) =>
		{
			StringBuilder builder = new();
			(string name,
			string @namespace,
			bool generateToString,
			ImmutableArray<(string Name, DbDataType Type, string? CustomType)> properties) = model;

			builder.AppendLine(
			$$"""
			/// <auto-generated/>
			
			using System.Data.Common;
			using OrmGenerator;

			namespace {{@namespace}};
			partial class {{name}} : IOrmModel<{{name}}>
			{
				public static {{name}} GetSingleModel(DbDataReader reader, ref int index) => new()
				{
			""");

			foreach ((string, DbDataType, string?) prop in properties)
			{
				(string Name, DbDataType Type, string? CustomType) = prop;
				if (Type == DbDataType.Unknown)
					builder.AppendLine($"		{Name} = {CustomType}.GetSingleModel(reader, ref index),");
				else
					builder.AppendLine($"		{Name} = reader.Get{(Type == DbDataType.Single ? "Float" : Type.ToString())}(index++),");
			}

			builder.AppendLine($$"""
				};
				public static {{name}} GetSingleModel(DbDataReader reader)
				{
					int index = 0;
					return GetSingleModel(reader, ref index);
				}			
			""");
			if (model.GenerateToString)
			{
				builder.AppendLine($$""""
						public override string ToString() =>
							$"""
					"""");
				foreach ((string Name, DbDataType, string?) prop in properties)
					builder.AppendLine($"		{prop.Name}: {{{prop.Name}}}");
				builder.AppendLine("	\"\"\";");
			}
			builder.AppendLine("}");

			spc.AddSource($"{@namespace}.{name}.g.cs", builder.ToString());
		});
	}

	private static bool GetToStringInfo(in GeneratorAttributeSyntaxContext context) => (bool)(context
		.Attributes[0]
		.NamedArguments
		.FirstOrDefault()
		.Value
		.Value ?? false);
}
